"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCurrentLocation = getCurrentLocation;
exports.setCurrentLocation = setCurrentLocation;
exports.setBabelTypes = setBabelTypes;
exports.default = void 0;

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// AUTOMATICALLY GENERATED BY scripts/generate.babel-types.js
let t = null;
let currentLocation = null;

function getCurrentLocation() {
  return currentLocation;
}

function setCurrentLocation(loc) {
  return currentLocation = loc;
}

function setBabelTypes(_t) {
  return t = _t;
}

const BabelTypes = {
  anyTypeAnnotation() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.AnyTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  arrayExpression(elements) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ArrayExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  arrayPattern(elements) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ArrayPattern.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  arrayTypeAnnotation(elementType) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ArrayTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  arrowFunctionExpression(params, body, async) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ArrowFunctionExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  assignmentExpression(operator, left, right) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.AssignmentExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  assignmentPattern(left, right) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.AssignmentPattern.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  awaitExpression(argument) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.AwaitExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  bigIntLiteral(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.BigIntLiteral.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  binaryExpression(operator, left, right) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.BinaryExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  bindExpression(object, callee) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.BindExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  blockStatement(body, directives) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.BlockStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  booleanLiteral(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.BooleanLiteral.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  booleanLiteralTypeAnnotation(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.BooleanLiteralTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  booleanTypeAnnotation() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.BooleanTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  breakStatement(label) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.BreakStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  callExpression(callee, _arguments) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.CallExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  catchClause(param, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.CatchClause.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  classBody(body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ClassBody.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  classDeclaration(id, superClass, body, decorators) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ClassDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  classExpression(id, superClass, body, decorators) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ClassExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  classImplements(id, typeParameters) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ClassImplements.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  classMethod(kind, key, params, body, computed, _static) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ClassMethod.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  classPrivateMethod(kind, key, params, body, _static) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ClassPrivateMethod.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  classPrivateProperty(key, value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ClassPrivateProperty.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  classProperty(key, value, typeAnnotation, decorators, computed) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ClassProperty.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  conditionalExpression(test, consequent, alternate) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ConditionalExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  continueStatement(label) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ContinueStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  debuggerStatement() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DebuggerStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  declareClass(id, typeParameters, _extends, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DeclareClass.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  declareExportAllDeclaration(source) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DeclareExportAllDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  declareExportDeclaration(declaration, specifiers, source) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DeclareExportDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  declareFunction(id) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DeclareFunction.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  declareInterface(id, typeParameters, _extends, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DeclareInterface.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  declareModule(id, body, kind) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DeclareModule.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  declareModuleExports(typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DeclareModuleExports.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  declareOpaqueType(id, typeParameters, supertype) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DeclareOpaqueType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  declareTypeAlias(id, typeParameters, right) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DeclareTypeAlias.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  declareVariable(id) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DeclareVariable.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  declaredPredicate(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DeclaredPredicate.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  decorator(expression) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.Decorator.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  directive(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.Directive.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  directiveLiteral(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DirectiveLiteral.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  doExpression(body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DoExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  doWhileStatement(test, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.DoWhileStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  emptyStatement() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.EmptyStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  emptyTypeAnnotation() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.EmptyTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  existsTypeAnnotation() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ExistsTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  exportAllDeclaration(source) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ExportAllDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  exportDefaultDeclaration(declaration) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ExportDefaultDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  exportDefaultSpecifier(exported) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ExportDefaultSpecifier.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  exportNamedDeclaration(declaration, specifiers, source) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ExportNamedDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  exportNamespaceSpecifier(exported) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ExportNamespaceSpecifier.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  exportSpecifier(local, exported) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ExportSpecifier.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  expressionStatement(expression) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ExpressionStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  file(program, comments, tokens) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.File.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  forInStatement(left, right, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ForInStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  forOfStatement(left, right, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ForOfStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  forStatement(init, test, update, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ForStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  functionDeclaration(id, params, body, generator, async) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.FunctionDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  functionExpression(id, params, body, generator, async) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.FunctionExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  functionTypeAnnotation(typeParameters, params, rest, returnType) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.FunctionTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  functionTypeParam(name, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.FunctionTypeParam.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  genericTypeAnnotation(id, typeParameters) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.GenericTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  identifier(name) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.Identifier.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  ifStatement(test, consequent, alternate) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.IfStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  import() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.Import.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  importDeclaration(specifiers, source) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ImportDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  importDefaultSpecifier(local) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ImportDefaultSpecifier.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  importNamespaceSpecifier(local) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ImportNamespaceSpecifier.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  importSpecifier(local, imported) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ImportSpecifier.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  inferredPredicate() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.InferredPredicate.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  interfaceDeclaration(id, typeParameters, _extends, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.InterfaceDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  interfaceExtends(id, typeParameters) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.InterfaceExtends.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  interfaceTypeAnnotation(_extends, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.InterfaceTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  interpreterDirective(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.InterpreterDirective.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  intersectionTypeAnnotation(types) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.IntersectionTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXAttribute(name, value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXAttribute.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXClosingElement(name) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXClosingElement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXClosingFragment() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXClosingFragment.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXElement(openingElement, closingElement, children, selfClosing) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXElement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXEmptyExpression() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXEmptyExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXExpressionContainer(expression) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXExpressionContainer.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXFragment(openingFragment, closingFragment, children) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXFragment.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXIdentifier(name) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXIdentifier.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXMemberExpression(object, property) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXMemberExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXNamespacedName(namespace, name) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXNamespacedName.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXOpeningElement(name, attributes, selfClosing) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXOpeningElement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXOpeningFragment() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXOpeningFragment.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXSpreadAttribute(argument) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXSpreadAttribute.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXSpreadChild(expression) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXSpreadChild.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  jSXText(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.JSXText.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  labeledStatement(label, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.LabeledStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  logicalExpression(operator, left, right) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.LogicalExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  memberExpression(object, property, computed, optional) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.MemberExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  metaProperty(meta, property) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.MetaProperty.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  mixedTypeAnnotation() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.MixedTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  newExpression(callee, _arguments) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.NewExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  noop() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.Noop.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  nullLiteral() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.NullLiteral.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  nullLiteralTypeAnnotation() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.NullLiteralTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  nullableTypeAnnotation(typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.NullableTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  numberLiteralTypeAnnotation(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.NumberLiteralTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  numberTypeAnnotation() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.NumberTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  numericLiteral(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.NumericLiteral.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  objectExpression(properties) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ObjectExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  objectMethod(kind, key, params, body, computed) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ObjectMethod.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  objectPattern(properties) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ObjectPattern.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  objectProperty(key, value, computed, shorthand, decorators) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ObjectProperty.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ObjectTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  objectTypeCallProperty(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ObjectTypeCallProperty.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  objectTypeIndexer(id, key, value, variance) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ObjectTypeIndexer.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  objectTypeInternalSlot(id, value, optional, _static, method) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ObjectTypeInternalSlot.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  objectTypeProperty(key, value, variance) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ObjectTypeProperty.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  objectTypeSpreadProperty(argument) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ObjectTypeSpreadProperty.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  opaqueType(id, typeParameters, supertype, impltype) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.OpaqueType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  optionalCallExpression(callee, _arguments, optional) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.OptionalCallExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  optionalMemberExpression(object, property, computed, optional) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.OptionalMemberExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  parenthesizedExpression(expression) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ParenthesizedExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  pipelineBareFunction(callee) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.PipelineBareFunction.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  pipelinePrimaryTopicReference() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.PipelinePrimaryTopicReference.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  pipelineTopicExpression(expression) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.PipelineTopicExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  privateName(id) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.PrivateName.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  program(body, directives, sourceType, interpreter) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.Program.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  qualifiedTypeIdentifier(id, qualification) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.QualifiedTypeIdentifier.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  regExpLiteral(pattern, flags) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.RegExpLiteral.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  restElement(argument) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.RestElement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  returnStatement(argument) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ReturnStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  sequenceExpression(expressions) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.SequenceExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  spreadElement(argument) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.SpreadElement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  stringLiteral(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.StringLiteral.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  stringLiteralTypeAnnotation(value) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.StringLiteralTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  stringTypeAnnotation() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.StringTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  super() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.Super.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  switchCase(test, consequent) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.SwitchCase.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  switchStatement(discriminant, cases) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.SwitchStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSAnyKeyword() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSAnyKeyword.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSArrayType(elementType) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSArrayType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSAsExpression(expression, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSAsExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSBooleanKeyword() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSBooleanKeyword.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSCallSignatureDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSConditionalType(checkType, extendsType, trueType, falseType) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSConditionalType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSConstructSignatureDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSConstructorType(typeParameters, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSConstructorType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSDeclareFunction(id, typeParameters, params, returnType) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSDeclareFunction.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSDeclareMethod(decorators, key, typeParameters, params, returnType) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSDeclareMethod.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSEnumDeclaration(id, members) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSEnumDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSEnumMember(id, initializer) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSEnumMember.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSExportAssignment(expression) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSExportAssignment.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSExpressionWithTypeArguments(expression, typeParameters) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSExpressionWithTypeArguments.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSExternalModuleReference(expression) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSExternalModuleReference.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSFunctionType(typeParameters, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSFunctionType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSImportEqualsDeclaration(id, moduleReference) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSImportEqualsDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSIndexSignature(parameters, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSIndexSignature.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSIndexedAccessType(objectType, indexType) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSIndexedAccessType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSInferType(typeParameter) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSInferType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSInterfaceBody(body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSInterfaceBody.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSInterfaceDeclaration(id, typeParameters, _extends, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSInterfaceDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSIntersectionType(types) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSIntersectionType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSLiteralType(literal) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSLiteralType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSMappedType(typeParameter, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSMappedType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSMethodSignature(key, typeParameters, parameters, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSMethodSignature.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSModuleBlock(body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSModuleBlock.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSModuleDeclaration(id, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSModuleDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSNamespaceExportDeclaration(id) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSNamespaceExportDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSNeverKeyword() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSNeverKeyword.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSNonNullExpression(expression) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSNonNullExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSNullKeyword() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSNullKeyword.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSNumberKeyword() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSNumberKeyword.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSObjectKeyword() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSObjectKeyword.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSOptionalType(typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSOptionalType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSParameterProperty(parameter) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSParameterProperty.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSParenthesizedType(typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSParenthesizedType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSPropertySignature(key, typeAnnotation, initializer) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSPropertySignature.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSQualifiedName(left, right) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSQualifiedName.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSRestType(typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSRestType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSStringKeyword() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSStringKeyword.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSSymbolKeyword() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSSymbolKeyword.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSThisType() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSThisType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTupleType(elementTypes) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTupleType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTypeAliasDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTypeAnnotation(typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTypeAssertion(typeAnnotation, expression) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTypeAssertion.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTypeLiteral(members) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTypeLiteral.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTypeOperator(typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTypeOperator.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTypeParameter(constraint, _default) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTypeParameter.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTypeParameterDeclaration(params) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTypeParameterDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTypeParameterInstantiation(params) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTypeParameterInstantiation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTypePredicate(parameterName, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTypePredicate.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTypeQuery(exprName) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTypeQuery.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSTypeReference(typeName, typeParameters) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSTypeReference.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSUndefinedKeyword() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSUndefinedKeyword.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSUnionType(types) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSUnionType.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSUnknownKeyword() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSUnknownKeyword.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tSVoidKeyword() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TSVoidKeyword.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  taggedTemplateExpression(tag, quasi) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TaggedTemplateExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  templateElement(value, tail) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TemplateElement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  templateLiteral(quasis, expressions) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TemplateLiteral.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  thisExpression() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ThisExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  thisTypeAnnotation() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ThisTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  throwStatement(argument) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.ThrowStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tryStatement(block, handler, finalizer) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TryStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  tupleTypeAnnotation(types) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TupleTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  typeAlias(id, typeParameters, right) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TypeAlias.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  typeAnnotation(typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  typeCastExpression(expression, typeAnnotation) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TypeCastExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  typeParameter(bound, _default, variance) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TypeParameter.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  typeParameterDeclaration(params) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TypeParameterDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  typeParameterInstantiation(params) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TypeParameterInstantiation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  typeofTypeAnnotation(argument) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.TypeofTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  unaryExpression(operator, argument, prefix) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.UnaryExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  unionTypeAnnotation(types) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.UnionTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  updateExpression(operator, argument, prefix) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.UpdateExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  variableDeclaration(kind, declarations) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.VariableDeclaration.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  variableDeclarator(id, init) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.VariableDeclarator.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  variance(kind) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.Variance.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  voidTypeAnnotation() {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.VoidTypeAnnotation.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  whileStatement(test, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.WhileStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  withStatement(object, body) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.WithStatement.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  yieldExpression(argument, delegate) {
    const args = [].slice.call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object';

    if (hasLoc) {
      args.pop();
    }

    return _objectSpread({}, t.YieldExpression.apply(t, args), {
      loc: hasLoc ? loc : getCurrentLocation()
    });
  },

  isAnyTypeAnnotation(value, opts) {
    return t.isAnyTypeAnnotation.apply(t, arguments);
  },

  isArrayExpression(value, opts) {
    return t.isArrayExpression.apply(t, arguments);
  },

  isArrayPattern(value, opts) {
    return t.isArrayPattern.apply(t, arguments);
  },

  isArrayTypeAnnotation(value, opts) {
    return t.isArrayTypeAnnotation.apply(t, arguments);
  },

  isArrowFunctionExpression(value, opts) {
    return t.isArrowFunctionExpression.apply(t, arguments);
  },

  isAssignmentExpression(value, opts) {
    return t.isAssignmentExpression.apply(t, arguments);
  },

  isAssignmentPattern(value, opts) {
    return t.isAssignmentPattern.apply(t, arguments);
  },

  isAwaitExpression(value, opts) {
    return t.isAwaitExpression.apply(t, arguments);
  },

  isBigIntLiteral(value, opts) {
    return t.isBigIntLiteral.apply(t, arguments);
  },

  isBinaryExpression(value, opts) {
    return t.isBinaryExpression.apply(t, arguments);
  },

  isBindExpression(value, opts) {
    return t.isBindExpression.apply(t, arguments);
  },

  isBlockStatement(value, opts) {
    return t.isBlockStatement.apply(t, arguments);
  },

  isBooleanLiteral(value, opts) {
    return t.isBooleanLiteral.apply(t, arguments);
  },

  isBooleanLiteralTypeAnnotation(value, opts) {
    return t.isBooleanLiteralTypeAnnotation.apply(t, arguments);
  },

  isBooleanTypeAnnotation(value, opts) {
    return t.isBooleanTypeAnnotation.apply(t, arguments);
  },

  isBreakStatement(value, opts) {
    return t.isBreakStatement.apply(t, arguments);
  },

  isCallExpression(value, opts) {
    return t.isCallExpression.apply(t, arguments);
  },

  isCatchClause(value, opts) {
    return t.isCatchClause.apply(t, arguments);
  },

  isClassBody(value, opts) {
    return t.isClassBody.apply(t, arguments);
  },

  isClassDeclaration(value, opts) {
    return t.isClassDeclaration.apply(t, arguments);
  },

  isClassExpression(value, opts) {
    return t.isClassExpression.apply(t, arguments);
  },

  isClassImplements(value, opts) {
    return t.isClassImplements.apply(t, arguments);
  },

  isClassMethod(value, opts) {
    return t.isClassMethod.apply(t, arguments);
  },

  isClassPrivateMethod(value, opts) {
    return t.isClassPrivateMethod.apply(t, arguments);
  },

  isClassPrivateProperty(value, opts) {
    return t.isClassPrivateProperty.apply(t, arguments);
  },

  isClassProperty(value, opts) {
    return t.isClassProperty.apply(t, arguments);
  },

  isConditionalExpression(value, opts) {
    return t.isConditionalExpression.apply(t, arguments);
  },

  isContinueStatement(value, opts) {
    return t.isContinueStatement.apply(t, arguments);
  },

  isDebuggerStatement(value, opts) {
    return t.isDebuggerStatement.apply(t, arguments);
  },

  isDeclareClass(value, opts) {
    return t.isDeclareClass.apply(t, arguments);
  },

  isDeclareExportAllDeclaration(value, opts) {
    return t.isDeclareExportAllDeclaration.apply(t, arguments);
  },

  isDeclareExportDeclaration(value, opts) {
    return t.isDeclareExportDeclaration.apply(t, arguments);
  },

  isDeclareFunction(value, opts) {
    return t.isDeclareFunction.apply(t, arguments);
  },

  isDeclareInterface(value, opts) {
    return t.isDeclareInterface.apply(t, arguments);
  },

  isDeclareModule(value, opts) {
    return t.isDeclareModule.apply(t, arguments);
  },

  isDeclareModuleExports(value, opts) {
    return t.isDeclareModuleExports.apply(t, arguments);
  },

  isDeclareOpaqueType(value, opts) {
    return t.isDeclareOpaqueType.apply(t, arguments);
  },

  isDeclareTypeAlias(value, opts) {
    return t.isDeclareTypeAlias.apply(t, arguments);
  },

  isDeclareVariable(value, opts) {
    return t.isDeclareVariable.apply(t, arguments);
  },

  isDeclaredPredicate(value, opts) {
    return t.isDeclaredPredicate.apply(t, arguments);
  },

  isDecorator(value, opts) {
    return t.isDecorator.apply(t, arguments);
  },

  isDirective(value, opts) {
    return t.isDirective.apply(t, arguments);
  },

  isDirectiveLiteral(value, opts) {
    return t.isDirectiveLiteral.apply(t, arguments);
  },

  isDoExpression(value, opts) {
    return t.isDoExpression.apply(t, arguments);
  },

  isDoWhileStatement(value, opts) {
    return t.isDoWhileStatement.apply(t, arguments);
  },

  isEmptyStatement(value, opts) {
    return t.isEmptyStatement.apply(t, arguments);
  },

  isEmptyTypeAnnotation(value, opts) {
    return t.isEmptyTypeAnnotation.apply(t, arguments);
  },

  isExistsTypeAnnotation(value, opts) {
    return t.isExistsTypeAnnotation.apply(t, arguments);
  },

  isExportAllDeclaration(value, opts) {
    return t.isExportAllDeclaration.apply(t, arguments);
  },

  isExportDefaultDeclaration(value, opts) {
    return t.isExportDefaultDeclaration.apply(t, arguments);
  },

  isExportDefaultSpecifier(value, opts) {
    return t.isExportDefaultSpecifier.apply(t, arguments);
  },

  isExportNamedDeclaration(value, opts) {
    return t.isExportNamedDeclaration.apply(t, arguments);
  },

  isExportNamespaceSpecifier(value, opts) {
    return t.isExportNamespaceSpecifier.apply(t, arguments);
  },

  isExportSpecifier(value, opts) {
    return t.isExportSpecifier.apply(t, arguments);
  },

  isExpressionStatement(value, opts) {
    return t.isExpressionStatement.apply(t, arguments);
  },

  isFile(value, opts) {
    return t.isFile.apply(t, arguments);
  },

  isForInStatement(value, opts) {
    return t.isForInStatement.apply(t, arguments);
  },

  isForOfStatement(value, opts) {
    return t.isForOfStatement.apply(t, arguments);
  },

  isForStatement(value, opts) {
    return t.isForStatement.apply(t, arguments);
  },

  isFunctionDeclaration(value, opts) {
    return t.isFunctionDeclaration.apply(t, arguments);
  },

  isFunctionExpression(value, opts) {
    return t.isFunctionExpression.apply(t, arguments);
  },

  isFunctionTypeAnnotation(value, opts) {
    return t.isFunctionTypeAnnotation.apply(t, arguments);
  },

  isFunctionTypeParam(value, opts) {
    return t.isFunctionTypeParam.apply(t, arguments);
  },

  isGenericTypeAnnotation(value, opts) {
    return t.isGenericTypeAnnotation.apply(t, arguments);
  },

  isIdentifier(value, opts) {
    return t.isIdentifier.apply(t, arguments);
  },

  isIfStatement(value, opts) {
    return t.isIfStatement.apply(t, arguments);
  },

  isImport(value, opts) {
    return t.isImport.apply(t, arguments);
  },

  isImportDeclaration(value, opts) {
    return t.isImportDeclaration.apply(t, arguments);
  },

  isImportDefaultSpecifier(value, opts) {
    return t.isImportDefaultSpecifier.apply(t, arguments);
  },

  isImportNamespaceSpecifier(value, opts) {
    return t.isImportNamespaceSpecifier.apply(t, arguments);
  },

  isImportSpecifier(value, opts) {
    return t.isImportSpecifier.apply(t, arguments);
  },

  isInferredPredicate(value, opts) {
    return t.isInferredPredicate.apply(t, arguments);
  },

  isInterfaceDeclaration(value, opts) {
    return t.isInterfaceDeclaration.apply(t, arguments);
  },

  isInterfaceExtends(value, opts) {
    return t.isInterfaceExtends.apply(t, arguments);
  },

  isInterfaceTypeAnnotation(value, opts) {
    return t.isInterfaceTypeAnnotation.apply(t, arguments);
  },

  isInterpreterDirective(value, opts) {
    return t.isInterpreterDirective.apply(t, arguments);
  },

  isIntersectionTypeAnnotation(value, opts) {
    return t.isIntersectionTypeAnnotation.apply(t, arguments);
  },

  isJSXAttribute(value, opts) {
    return t.isJSXAttribute.apply(t, arguments);
  },

  isJSXClosingElement(value, opts) {
    return t.isJSXClosingElement.apply(t, arguments);
  },

  isJSXClosingFragment(value, opts) {
    return t.isJSXClosingFragment.apply(t, arguments);
  },

  isJSXElement(value, opts) {
    return t.isJSXElement.apply(t, arguments);
  },

  isJSXEmptyExpression(value, opts) {
    return t.isJSXEmptyExpression.apply(t, arguments);
  },

  isJSXExpressionContainer(value, opts) {
    return t.isJSXExpressionContainer.apply(t, arguments);
  },

  isJSXFragment(value, opts) {
    return t.isJSXFragment.apply(t, arguments);
  },

  isJSXIdentifier(value, opts) {
    return t.isJSXIdentifier.apply(t, arguments);
  },

  isJSXMemberExpression(value, opts) {
    return t.isJSXMemberExpression.apply(t, arguments);
  },

  isJSXNamespacedName(value, opts) {
    return t.isJSXNamespacedName.apply(t, arguments);
  },

  isJSXOpeningElement(value, opts) {
    return t.isJSXOpeningElement.apply(t, arguments);
  },

  isJSXOpeningFragment(value, opts) {
    return t.isJSXOpeningFragment.apply(t, arguments);
  },

  isJSXSpreadAttribute(value, opts) {
    return t.isJSXSpreadAttribute.apply(t, arguments);
  },

  isJSXSpreadChild(value, opts) {
    return t.isJSXSpreadChild.apply(t, arguments);
  },

  isJSXText(value, opts) {
    return t.isJSXText.apply(t, arguments);
  },

  isLabeledStatement(value, opts) {
    return t.isLabeledStatement.apply(t, arguments);
  },

  isLogicalExpression(value, opts) {
    return t.isLogicalExpression.apply(t, arguments);
  },

  isMemberExpression(value, opts) {
    return t.isMemberExpression.apply(t, arguments);
  },

  isMetaProperty(value, opts) {
    return t.isMetaProperty.apply(t, arguments);
  },

  isMixedTypeAnnotation(value, opts) {
    return t.isMixedTypeAnnotation.apply(t, arguments);
  },

  isNewExpression(value, opts) {
    return t.isNewExpression.apply(t, arguments);
  },

  isNoop(value, opts) {
    return t.isNoop.apply(t, arguments);
  },

  isNullLiteral(value, opts) {
    return t.isNullLiteral.apply(t, arguments);
  },

  isNullLiteralTypeAnnotation(value, opts) {
    return t.isNullLiteralTypeAnnotation.apply(t, arguments);
  },

  isNullableTypeAnnotation(value, opts) {
    return t.isNullableTypeAnnotation.apply(t, arguments);
  },

  isNumberLiteralTypeAnnotation(value, opts) {
    return t.isNumberLiteralTypeAnnotation.apply(t, arguments);
  },

  isNumberTypeAnnotation(value, opts) {
    return t.isNumberTypeAnnotation.apply(t, arguments);
  },

  isNumericLiteral(value, opts) {
    return t.isNumericLiteral.apply(t, arguments);
  },

  isObjectExpression(value, opts) {
    return t.isObjectExpression.apply(t, arguments);
  },

  isObjectMethod(value, opts) {
    return t.isObjectMethod.apply(t, arguments);
  },

  isObjectPattern(value, opts) {
    return t.isObjectPattern.apply(t, arguments);
  },

  isObjectProperty(value, opts) {
    return t.isObjectProperty.apply(t, arguments);
  },

  isObjectTypeAnnotation(value, opts) {
    return t.isObjectTypeAnnotation.apply(t, arguments);
  },

  isObjectTypeCallProperty(value, opts) {
    return t.isObjectTypeCallProperty.apply(t, arguments);
  },

  isObjectTypeIndexer(value, opts) {
    return t.isObjectTypeIndexer.apply(t, arguments);
  },

  isObjectTypeInternalSlot(value, opts) {
    return t.isObjectTypeInternalSlot.apply(t, arguments);
  },

  isObjectTypeProperty(value, opts) {
    return t.isObjectTypeProperty.apply(t, arguments);
  },

  isObjectTypeSpreadProperty(value, opts) {
    return t.isObjectTypeSpreadProperty.apply(t, arguments);
  },

  isOpaqueType(value, opts) {
    return t.isOpaqueType.apply(t, arguments);
  },

  isOptionalCallExpression(value, opts) {
    return t.isOptionalCallExpression.apply(t, arguments);
  },

  isOptionalMemberExpression(value, opts) {
    return t.isOptionalMemberExpression.apply(t, arguments);
  },

  isParenthesizedExpression(value, opts) {
    return t.isParenthesizedExpression.apply(t, arguments);
  },

  isPipelineBareFunction(value, opts) {
    return t.isPipelineBareFunction.apply(t, arguments);
  },

  isPipelinePrimaryTopicReference(value, opts) {
    return t.isPipelinePrimaryTopicReference.apply(t, arguments);
  },

  isPipelineTopicExpression(value, opts) {
    return t.isPipelineTopicExpression.apply(t, arguments);
  },

  isPrivateName(value, opts) {
    return t.isPrivateName.apply(t, arguments);
  },

  isProgram(value, opts) {
    return t.isProgram.apply(t, arguments);
  },

  isQualifiedTypeIdentifier(value, opts) {
    return t.isQualifiedTypeIdentifier.apply(t, arguments);
  },

  isRegExpLiteral(value, opts) {
    return t.isRegExpLiteral.apply(t, arguments);
  },

  isRestElement(value, opts) {
    return t.isRestElement.apply(t, arguments);
  },

  isReturnStatement(value, opts) {
    return t.isReturnStatement.apply(t, arguments);
  },

  isSequenceExpression(value, opts) {
    return t.isSequenceExpression.apply(t, arguments);
  },

  isSpreadElement(value, opts) {
    return t.isSpreadElement.apply(t, arguments);
  },

  isStringLiteral(value, opts) {
    return t.isStringLiteral.apply(t, arguments);
  },

  isStringLiteralTypeAnnotation(value, opts) {
    return t.isStringLiteralTypeAnnotation.apply(t, arguments);
  },

  isStringTypeAnnotation(value, opts) {
    return t.isStringTypeAnnotation.apply(t, arguments);
  },

  isSuper(value, opts) {
    return t.isSuper.apply(t, arguments);
  },

  isSwitchCase(value, opts) {
    return t.isSwitchCase.apply(t, arguments);
  },

  isSwitchStatement(value, opts) {
    return t.isSwitchStatement.apply(t, arguments);
  },

  isTSAnyKeyword(value, opts) {
    return t.isTSAnyKeyword.apply(t, arguments);
  },

  isTSArrayType(value, opts) {
    return t.isTSArrayType.apply(t, arguments);
  },

  isTSAsExpression(value, opts) {
    return t.isTSAsExpression.apply(t, arguments);
  },

  isTSBooleanKeyword(value, opts) {
    return t.isTSBooleanKeyword.apply(t, arguments);
  },

  isTSCallSignatureDeclaration(value, opts) {
    return t.isTSCallSignatureDeclaration.apply(t, arguments);
  },

  isTSConditionalType(value, opts) {
    return t.isTSConditionalType.apply(t, arguments);
  },

  isTSConstructSignatureDeclaration(value, opts) {
    return t.isTSConstructSignatureDeclaration.apply(t, arguments);
  },

  isTSConstructorType(value, opts) {
    return t.isTSConstructorType.apply(t, arguments);
  },

  isTSDeclareFunction(value, opts) {
    return t.isTSDeclareFunction.apply(t, arguments);
  },

  isTSDeclareMethod(value, opts) {
    return t.isTSDeclareMethod.apply(t, arguments);
  },

  isTSEnumDeclaration(value, opts) {
    return t.isTSEnumDeclaration.apply(t, arguments);
  },

  isTSEnumMember(value, opts) {
    return t.isTSEnumMember.apply(t, arguments);
  },

  isTSExportAssignment(value, opts) {
    return t.isTSExportAssignment.apply(t, arguments);
  },

  isTSExpressionWithTypeArguments(value, opts) {
    return t.isTSExpressionWithTypeArguments.apply(t, arguments);
  },

  isTSExternalModuleReference(value, opts) {
    return t.isTSExternalModuleReference.apply(t, arguments);
  },

  isTSFunctionType(value, opts) {
    return t.isTSFunctionType.apply(t, arguments);
  },

  isTSImportEqualsDeclaration(value, opts) {
    return t.isTSImportEqualsDeclaration.apply(t, arguments);
  },

  isTSIndexSignature(value, opts) {
    return t.isTSIndexSignature.apply(t, arguments);
  },

  isTSIndexedAccessType(value, opts) {
    return t.isTSIndexedAccessType.apply(t, arguments);
  },

  isTSInferType(value, opts) {
    return t.isTSInferType.apply(t, arguments);
  },

  isTSInterfaceBody(value, opts) {
    return t.isTSInterfaceBody.apply(t, arguments);
  },

  isTSInterfaceDeclaration(value, opts) {
    return t.isTSInterfaceDeclaration.apply(t, arguments);
  },

  isTSIntersectionType(value, opts) {
    return t.isTSIntersectionType.apply(t, arguments);
  },

  isTSLiteralType(value, opts) {
    return t.isTSLiteralType.apply(t, arguments);
  },

  isTSMappedType(value, opts) {
    return t.isTSMappedType.apply(t, arguments);
  },

  isTSMethodSignature(value, opts) {
    return t.isTSMethodSignature.apply(t, arguments);
  },

  isTSModuleBlock(value, opts) {
    return t.isTSModuleBlock.apply(t, arguments);
  },

  isTSModuleDeclaration(value, opts) {
    return t.isTSModuleDeclaration.apply(t, arguments);
  },

  isTSNamespaceExportDeclaration(value, opts) {
    return t.isTSNamespaceExportDeclaration.apply(t, arguments);
  },

  isTSNeverKeyword(value, opts) {
    return t.isTSNeverKeyword.apply(t, arguments);
  },

  isTSNonNullExpression(value, opts) {
    return t.isTSNonNullExpression.apply(t, arguments);
  },

  isTSNullKeyword(value, opts) {
    return t.isTSNullKeyword.apply(t, arguments);
  },

  isTSNumberKeyword(value, opts) {
    return t.isTSNumberKeyword.apply(t, arguments);
  },

  isTSObjectKeyword(value, opts) {
    return t.isTSObjectKeyword.apply(t, arguments);
  },

  isTSOptionalType(value, opts) {
    return t.isTSOptionalType.apply(t, arguments);
  },

  isTSParameterProperty(value, opts) {
    return t.isTSParameterProperty.apply(t, arguments);
  },

  isTSParenthesizedType(value, opts) {
    return t.isTSParenthesizedType.apply(t, arguments);
  },

  isTSPropertySignature(value, opts) {
    return t.isTSPropertySignature.apply(t, arguments);
  },

  isTSQualifiedName(value, opts) {
    return t.isTSQualifiedName.apply(t, arguments);
  },

  isTSRestType(value, opts) {
    return t.isTSRestType.apply(t, arguments);
  },

  isTSStringKeyword(value, opts) {
    return t.isTSStringKeyword.apply(t, arguments);
  },

  isTSSymbolKeyword(value, opts) {
    return t.isTSSymbolKeyword.apply(t, arguments);
  },

  isTSThisType(value, opts) {
    return t.isTSThisType.apply(t, arguments);
  },

  isTSTupleType(value, opts) {
    return t.isTSTupleType.apply(t, arguments);
  },

  isTSTypeAliasDeclaration(value, opts) {
    return t.isTSTypeAliasDeclaration.apply(t, arguments);
  },

  isTSTypeAnnotation(value, opts) {
    return t.isTSTypeAnnotation.apply(t, arguments);
  },

  isTSTypeAssertion(value, opts) {
    return t.isTSTypeAssertion.apply(t, arguments);
  },

  isTSTypeLiteral(value, opts) {
    return t.isTSTypeLiteral.apply(t, arguments);
  },

  isTSTypeOperator(value, opts) {
    return t.isTSTypeOperator.apply(t, arguments);
  },

  isTSTypeParameter(value, opts) {
    return t.isTSTypeParameter.apply(t, arguments);
  },

  isTSTypeParameterDeclaration(value, opts) {
    return t.isTSTypeParameterDeclaration.apply(t, arguments);
  },

  isTSTypeParameterInstantiation(value, opts) {
    return t.isTSTypeParameterInstantiation.apply(t, arguments);
  },

  isTSTypePredicate(value, opts) {
    return t.isTSTypePredicate.apply(t, arguments);
  },

  isTSTypeQuery(value, opts) {
    return t.isTSTypeQuery.apply(t, arguments);
  },

  isTSTypeReference(value, opts) {
    return t.isTSTypeReference.apply(t, arguments);
  },

  isTSUndefinedKeyword(value, opts) {
    return t.isTSUndefinedKeyword.apply(t, arguments);
  },

  isTSUnionType(value, opts) {
    return t.isTSUnionType.apply(t, arguments);
  },

  isTSUnknownKeyword(value, opts) {
    return t.isTSUnknownKeyword.apply(t, arguments);
  },

  isTSVoidKeyword(value, opts) {
    return t.isTSVoidKeyword.apply(t, arguments);
  },

  isTaggedTemplateExpression(value, opts) {
    return t.isTaggedTemplateExpression.apply(t, arguments);
  },

  isTemplateElement(value, opts) {
    return t.isTemplateElement.apply(t, arguments);
  },

  isTemplateLiteral(value, opts) {
    return t.isTemplateLiteral.apply(t, arguments);
  },

  isThisExpression(value, opts) {
    return t.isThisExpression.apply(t, arguments);
  },

  isThisTypeAnnotation(value, opts) {
    return t.isThisTypeAnnotation.apply(t, arguments);
  },

  isThrowStatement(value, opts) {
    return t.isThrowStatement.apply(t, arguments);
  },

  isTryStatement(value, opts) {
    return t.isTryStatement.apply(t, arguments);
  },

  isTupleTypeAnnotation(value, opts) {
    return t.isTupleTypeAnnotation.apply(t, arguments);
  },

  isTypeAlias(value, opts) {
    return t.isTypeAlias.apply(t, arguments);
  },

  isTypeAnnotation(value, opts) {
    return t.isTypeAnnotation.apply(t, arguments);
  },

  isTypeCastExpression(value, opts) {
    return t.isTypeCastExpression.apply(t, arguments);
  },

  isTypeParameter(value, opts) {
    return t.isTypeParameter.apply(t, arguments);
  },

  isTypeParameterDeclaration(value, opts) {
    return t.isTypeParameterDeclaration.apply(t, arguments);
  },

  isTypeParameterInstantiation(value, opts) {
    return t.isTypeParameterInstantiation.apply(t, arguments);
  },

  isTypeofTypeAnnotation(value, opts) {
    return t.isTypeofTypeAnnotation.apply(t, arguments);
  },

  isUnaryExpression(value, opts) {
    return t.isUnaryExpression.apply(t, arguments);
  },

  isUnionTypeAnnotation(value, opts) {
    return t.isUnionTypeAnnotation.apply(t, arguments);
  },

  isUpdateExpression(value, opts) {
    return t.isUpdateExpression.apply(t, arguments);
  },

  isVariableDeclaration(value, opts) {
    return t.isVariableDeclaration.apply(t, arguments);
  },

  isVariableDeclarator(value, opts) {
    return t.isVariableDeclarator.apply(t, arguments);
  },

  isVariance(value, opts) {
    return t.isVariance.apply(t, arguments);
  },

  isVoidTypeAnnotation(value, opts) {
    return t.isVoidTypeAnnotation.apply(t, arguments);
  },

  isWhileStatement(value, opts) {
    return t.isWhileStatement.apply(t, arguments);
  },

  isWithStatement(value, opts) {
    return t.isWithStatement.apply(t, arguments);
  },

  isYieldExpression(value, opts) {
    return t.isYieldExpression.apply(t, arguments);
  },

  assertAnyTypeAnnotation(value, opts) {
    return t.assertAnyTypeAnnotation.apply(t, arguments);
  },

  assertArrayExpression(value, opts) {
    return t.assertArrayExpression.apply(t, arguments);
  },

  assertArrayPattern(value, opts) {
    return t.assertArrayPattern.apply(t, arguments);
  },

  assertArrayTypeAnnotation(value, opts) {
    return t.assertArrayTypeAnnotation.apply(t, arguments);
  },

  assertArrowFunctionExpression(value, opts) {
    return t.assertArrowFunctionExpression.apply(t, arguments);
  },

  assertAssignmentExpression(value, opts) {
    return t.assertAssignmentExpression.apply(t, arguments);
  },

  assertAssignmentPattern(value, opts) {
    return t.assertAssignmentPattern.apply(t, arguments);
  },

  assertAwaitExpression(value, opts) {
    return t.assertAwaitExpression.apply(t, arguments);
  },

  assertBigIntLiteral(value, opts) {
    return t.assertBigIntLiteral.apply(t, arguments);
  },

  assertBinaryExpression(value, opts) {
    return t.assertBinaryExpression.apply(t, arguments);
  },

  assertBindExpression(value, opts) {
    return t.assertBindExpression.apply(t, arguments);
  },

  assertBlockStatement(value, opts) {
    return t.assertBlockStatement.apply(t, arguments);
  },

  assertBooleanLiteral(value, opts) {
    return t.assertBooleanLiteral.apply(t, arguments);
  },

  assertBooleanLiteralTypeAnnotation(value, opts) {
    return t.assertBooleanLiteralTypeAnnotation.apply(t, arguments);
  },

  assertBooleanTypeAnnotation(value, opts) {
    return t.assertBooleanTypeAnnotation.apply(t, arguments);
  },

  assertBreakStatement(value, opts) {
    return t.assertBreakStatement.apply(t, arguments);
  },

  assertCallExpression(value, opts) {
    return t.assertCallExpression.apply(t, arguments);
  },

  assertCatchClause(value, opts) {
    return t.assertCatchClause.apply(t, arguments);
  },

  assertClassBody(value, opts) {
    return t.assertClassBody.apply(t, arguments);
  },

  assertClassDeclaration(value, opts) {
    return t.assertClassDeclaration.apply(t, arguments);
  },

  assertClassExpression(value, opts) {
    return t.assertClassExpression.apply(t, arguments);
  },

  assertClassImplements(value, opts) {
    return t.assertClassImplements.apply(t, arguments);
  },

  assertClassMethod(value, opts) {
    return t.assertClassMethod.apply(t, arguments);
  },

  assertClassPrivateMethod(value, opts) {
    return t.assertClassPrivateMethod.apply(t, arguments);
  },

  assertClassPrivateProperty(value, opts) {
    return t.assertClassPrivateProperty.apply(t, arguments);
  },

  assertClassProperty(value, opts) {
    return t.assertClassProperty.apply(t, arguments);
  },

  assertConditionalExpression(value, opts) {
    return t.assertConditionalExpression.apply(t, arguments);
  },

  assertContinueStatement(value, opts) {
    return t.assertContinueStatement.apply(t, arguments);
  },

  assertDebuggerStatement(value, opts) {
    return t.assertDebuggerStatement.apply(t, arguments);
  },

  assertDeclareClass(value, opts) {
    return t.assertDeclareClass.apply(t, arguments);
  },

  assertDeclareExportAllDeclaration(value, opts) {
    return t.assertDeclareExportAllDeclaration.apply(t, arguments);
  },

  assertDeclareExportDeclaration(value, opts) {
    return t.assertDeclareExportDeclaration.apply(t, arguments);
  },

  assertDeclareFunction(value, opts) {
    return t.assertDeclareFunction.apply(t, arguments);
  },

  assertDeclareInterface(value, opts) {
    return t.assertDeclareInterface.apply(t, arguments);
  },

  assertDeclareModule(value, opts) {
    return t.assertDeclareModule.apply(t, arguments);
  },

  assertDeclareModuleExports(value, opts) {
    return t.assertDeclareModuleExports.apply(t, arguments);
  },

  assertDeclareOpaqueType(value, opts) {
    return t.assertDeclareOpaqueType.apply(t, arguments);
  },

  assertDeclareTypeAlias(value, opts) {
    return t.assertDeclareTypeAlias.apply(t, arguments);
  },

  assertDeclareVariable(value, opts) {
    return t.assertDeclareVariable.apply(t, arguments);
  },

  assertDeclaredPredicate(value, opts) {
    return t.assertDeclaredPredicate.apply(t, arguments);
  },

  assertDecorator(value, opts) {
    return t.assertDecorator.apply(t, arguments);
  },

  assertDirective(value, opts) {
    return t.assertDirective.apply(t, arguments);
  },

  assertDirectiveLiteral(value, opts) {
    return t.assertDirectiveLiteral.apply(t, arguments);
  },

  assertDoExpression(value, opts) {
    return t.assertDoExpression.apply(t, arguments);
  },

  assertDoWhileStatement(value, opts) {
    return t.assertDoWhileStatement.apply(t, arguments);
  },

  assertEmptyStatement(value, opts) {
    return t.assertEmptyStatement.apply(t, arguments);
  },

  assertEmptyTypeAnnotation(value, opts) {
    return t.assertEmptyTypeAnnotation.apply(t, arguments);
  },

  assertExistsTypeAnnotation(value, opts) {
    return t.assertExistsTypeAnnotation.apply(t, arguments);
  },

  assertExportAllDeclaration(value, opts) {
    return t.assertExportAllDeclaration.apply(t, arguments);
  },

  assertExportDefaultDeclaration(value, opts) {
    return t.assertExportDefaultDeclaration.apply(t, arguments);
  },

  assertExportDefaultSpecifier(value, opts) {
    return t.assertExportDefaultSpecifier.apply(t, arguments);
  },

  assertExportNamedDeclaration(value, opts) {
    return t.assertExportNamedDeclaration.apply(t, arguments);
  },

  assertExportNamespaceSpecifier(value, opts) {
    return t.assertExportNamespaceSpecifier.apply(t, arguments);
  },

  assertExportSpecifier(value, opts) {
    return t.assertExportSpecifier.apply(t, arguments);
  },

  assertExpressionStatement(value, opts) {
    return t.assertExpressionStatement.apply(t, arguments);
  },

  assertFile(value, opts) {
    return t.assertFile.apply(t, arguments);
  },

  assertForInStatement(value, opts) {
    return t.assertForInStatement.apply(t, arguments);
  },

  assertForOfStatement(value, opts) {
    return t.assertForOfStatement.apply(t, arguments);
  },

  assertForStatement(value, opts) {
    return t.assertForStatement.apply(t, arguments);
  },

  assertFunctionDeclaration(value, opts) {
    return t.assertFunctionDeclaration.apply(t, arguments);
  },

  assertFunctionExpression(value, opts) {
    return t.assertFunctionExpression.apply(t, arguments);
  },

  assertFunctionTypeAnnotation(value, opts) {
    return t.assertFunctionTypeAnnotation.apply(t, arguments);
  },

  assertFunctionTypeParam(value, opts) {
    return t.assertFunctionTypeParam.apply(t, arguments);
  },

  assertGenericTypeAnnotation(value, opts) {
    return t.assertGenericTypeAnnotation.apply(t, arguments);
  },

  assertIdentifier(value, opts) {
    return t.assertIdentifier.apply(t, arguments);
  },

  assertIfStatement(value, opts) {
    return t.assertIfStatement.apply(t, arguments);
  },

  assertImport(value, opts) {
    return t.assertImport.apply(t, arguments);
  },

  assertImportDeclaration(value, opts) {
    return t.assertImportDeclaration.apply(t, arguments);
  },

  assertImportDefaultSpecifier(value, opts) {
    return t.assertImportDefaultSpecifier.apply(t, arguments);
  },

  assertImportNamespaceSpecifier(value, opts) {
    return t.assertImportNamespaceSpecifier.apply(t, arguments);
  },

  assertImportSpecifier(value, opts) {
    return t.assertImportSpecifier.apply(t, arguments);
  },

  assertInferredPredicate(value, opts) {
    return t.assertInferredPredicate.apply(t, arguments);
  },

  assertInterfaceDeclaration(value, opts) {
    return t.assertInterfaceDeclaration.apply(t, arguments);
  },

  assertInterfaceExtends(value, opts) {
    return t.assertInterfaceExtends.apply(t, arguments);
  },

  assertInterfaceTypeAnnotation(value, opts) {
    return t.assertInterfaceTypeAnnotation.apply(t, arguments);
  },

  assertInterpreterDirective(value, opts) {
    return t.assertInterpreterDirective.apply(t, arguments);
  },

  assertIntersectionTypeAnnotation(value, opts) {
    return t.assertIntersectionTypeAnnotation.apply(t, arguments);
  },

  assertJSXAttribute(value, opts) {
    return t.assertJSXAttribute.apply(t, arguments);
  },

  assertJSXClosingElement(value, opts) {
    return t.assertJSXClosingElement.apply(t, arguments);
  },

  assertJSXClosingFragment(value, opts) {
    return t.assertJSXClosingFragment.apply(t, arguments);
  },

  assertJSXElement(value, opts) {
    return t.assertJSXElement.apply(t, arguments);
  },

  assertJSXEmptyExpression(value, opts) {
    return t.assertJSXEmptyExpression.apply(t, arguments);
  },

  assertJSXExpressionContainer(value, opts) {
    return t.assertJSXExpressionContainer.apply(t, arguments);
  },

  assertJSXFragment(value, opts) {
    return t.assertJSXFragment.apply(t, arguments);
  },

  assertJSXIdentifier(value, opts) {
    return t.assertJSXIdentifier.apply(t, arguments);
  },

  assertJSXMemberExpression(value, opts) {
    return t.assertJSXMemberExpression.apply(t, arguments);
  },

  assertJSXNamespacedName(value, opts) {
    return t.assertJSXNamespacedName.apply(t, arguments);
  },

  assertJSXOpeningElement(value, opts) {
    return t.assertJSXOpeningElement.apply(t, arguments);
  },

  assertJSXOpeningFragment(value, opts) {
    return t.assertJSXOpeningFragment.apply(t, arguments);
  },

  assertJSXSpreadAttribute(value, opts) {
    return t.assertJSXSpreadAttribute.apply(t, arguments);
  },

  assertJSXSpreadChild(value, opts) {
    return t.assertJSXSpreadChild.apply(t, arguments);
  },

  assertJSXText(value, opts) {
    return t.assertJSXText.apply(t, arguments);
  },

  assertLabeledStatement(value, opts) {
    return t.assertLabeledStatement.apply(t, arguments);
  },

  assertLogicalExpression(value, opts) {
    return t.assertLogicalExpression.apply(t, arguments);
  },

  assertMemberExpression(value, opts) {
    return t.assertMemberExpression.apply(t, arguments);
  },

  assertMetaProperty(value, opts) {
    return t.assertMetaProperty.apply(t, arguments);
  },

  assertMixedTypeAnnotation(value, opts) {
    return t.assertMixedTypeAnnotation.apply(t, arguments);
  },

  assertNewExpression(value, opts) {
    return t.assertNewExpression.apply(t, arguments);
  },

  assertNoop(value, opts) {
    return t.assertNoop.apply(t, arguments);
  },

  assertNullLiteral(value, opts) {
    return t.assertNullLiteral.apply(t, arguments);
  },

  assertNullLiteralTypeAnnotation(value, opts) {
    return t.assertNullLiteralTypeAnnotation.apply(t, arguments);
  },

  assertNullableTypeAnnotation(value, opts) {
    return t.assertNullableTypeAnnotation.apply(t, arguments);
  },

  assertNumberLiteralTypeAnnotation(value, opts) {
    return t.assertNumberLiteralTypeAnnotation.apply(t, arguments);
  },

  assertNumberTypeAnnotation(value, opts) {
    return t.assertNumberTypeAnnotation.apply(t, arguments);
  },

  assertNumericLiteral(value, opts) {
    return t.assertNumericLiteral.apply(t, arguments);
  },

  assertObjectExpression(value, opts) {
    return t.assertObjectExpression.apply(t, arguments);
  },

  assertObjectMethod(value, opts) {
    return t.assertObjectMethod.apply(t, arguments);
  },

  assertObjectPattern(value, opts) {
    return t.assertObjectPattern.apply(t, arguments);
  },

  assertObjectProperty(value, opts) {
    return t.assertObjectProperty.apply(t, arguments);
  },

  assertObjectTypeAnnotation(value, opts) {
    return t.assertObjectTypeAnnotation.apply(t, arguments);
  },

  assertObjectTypeCallProperty(value, opts) {
    return t.assertObjectTypeCallProperty.apply(t, arguments);
  },

  assertObjectTypeIndexer(value, opts) {
    return t.assertObjectTypeIndexer.apply(t, arguments);
  },

  assertObjectTypeInternalSlot(value, opts) {
    return t.assertObjectTypeInternalSlot.apply(t, arguments);
  },

  assertObjectTypeProperty(value, opts) {
    return t.assertObjectTypeProperty.apply(t, arguments);
  },

  assertObjectTypeSpreadProperty(value, opts) {
    return t.assertObjectTypeSpreadProperty.apply(t, arguments);
  },

  assertOpaqueType(value, opts) {
    return t.assertOpaqueType.apply(t, arguments);
  },

  assertOptionalCallExpression(value, opts) {
    return t.assertOptionalCallExpression.apply(t, arguments);
  },

  assertOptionalMemberExpression(value, opts) {
    return t.assertOptionalMemberExpression.apply(t, arguments);
  },

  assertParenthesizedExpression(value, opts) {
    return t.assertParenthesizedExpression.apply(t, arguments);
  },

  assertPipelineBareFunction(value, opts) {
    return t.assertPipelineBareFunction.apply(t, arguments);
  },

  assertPipelinePrimaryTopicReference(value, opts) {
    return t.assertPipelinePrimaryTopicReference.apply(t, arguments);
  },

  assertPipelineTopicExpression(value, opts) {
    return t.assertPipelineTopicExpression.apply(t, arguments);
  },

  assertPrivateName(value, opts) {
    return t.assertPrivateName.apply(t, arguments);
  },

  assertProgram(value, opts) {
    return t.assertProgram.apply(t, arguments);
  },

  assertQualifiedTypeIdentifier(value, opts) {
    return t.assertQualifiedTypeIdentifier.apply(t, arguments);
  },

  assertRegExpLiteral(value, opts) {
    return t.assertRegExpLiteral.apply(t, arguments);
  },

  assertRestElement(value, opts) {
    return t.assertRestElement.apply(t, arguments);
  },

  assertReturnStatement(value, opts) {
    return t.assertReturnStatement.apply(t, arguments);
  },

  assertSequenceExpression(value, opts) {
    return t.assertSequenceExpression.apply(t, arguments);
  },

  assertSpreadElement(value, opts) {
    return t.assertSpreadElement.apply(t, arguments);
  },

  assertStringLiteral(value, opts) {
    return t.assertStringLiteral.apply(t, arguments);
  },

  assertStringLiteralTypeAnnotation(value, opts) {
    return t.assertStringLiteralTypeAnnotation.apply(t, arguments);
  },

  assertStringTypeAnnotation(value, opts) {
    return t.assertStringTypeAnnotation.apply(t, arguments);
  },

  assertSuper(value, opts) {
    return t.assertSuper.apply(t, arguments);
  },

  assertSwitchCase(value, opts) {
    return t.assertSwitchCase.apply(t, arguments);
  },

  assertSwitchStatement(value, opts) {
    return t.assertSwitchStatement.apply(t, arguments);
  },

  assertTSAnyKeyword(value, opts) {
    return t.assertTSAnyKeyword.apply(t, arguments);
  },

  assertTSArrayType(value, opts) {
    return t.assertTSArrayType.apply(t, arguments);
  },

  assertTSAsExpression(value, opts) {
    return t.assertTSAsExpression.apply(t, arguments);
  },

  assertTSBooleanKeyword(value, opts) {
    return t.assertTSBooleanKeyword.apply(t, arguments);
  },

  assertTSCallSignatureDeclaration(value, opts) {
    return t.assertTSCallSignatureDeclaration.apply(t, arguments);
  },

  assertTSConditionalType(value, opts) {
    return t.assertTSConditionalType.apply(t, arguments);
  },

  assertTSConstructSignatureDeclaration(value, opts) {
    return t.assertTSConstructSignatureDeclaration.apply(t, arguments);
  },

  assertTSConstructorType(value, opts) {
    return t.assertTSConstructorType.apply(t, arguments);
  },

  assertTSDeclareFunction(value, opts) {
    return t.assertTSDeclareFunction.apply(t, arguments);
  },

  assertTSDeclareMethod(value, opts) {
    return t.assertTSDeclareMethod.apply(t, arguments);
  },

  assertTSEnumDeclaration(value, opts) {
    return t.assertTSEnumDeclaration.apply(t, arguments);
  },

  assertTSEnumMember(value, opts) {
    return t.assertTSEnumMember.apply(t, arguments);
  },

  assertTSExportAssignment(value, opts) {
    return t.assertTSExportAssignment.apply(t, arguments);
  },

  assertTSExpressionWithTypeArguments(value, opts) {
    return t.assertTSExpressionWithTypeArguments.apply(t, arguments);
  },

  assertTSExternalModuleReference(value, opts) {
    return t.assertTSExternalModuleReference.apply(t, arguments);
  },

  assertTSFunctionType(value, opts) {
    return t.assertTSFunctionType.apply(t, arguments);
  },

  assertTSImportEqualsDeclaration(value, opts) {
    return t.assertTSImportEqualsDeclaration.apply(t, arguments);
  },

  assertTSIndexSignature(value, opts) {
    return t.assertTSIndexSignature.apply(t, arguments);
  },

  assertTSIndexedAccessType(value, opts) {
    return t.assertTSIndexedAccessType.apply(t, arguments);
  },

  assertTSInferType(value, opts) {
    return t.assertTSInferType.apply(t, arguments);
  },

  assertTSInterfaceBody(value, opts) {
    return t.assertTSInterfaceBody.apply(t, arguments);
  },

  assertTSInterfaceDeclaration(value, opts) {
    return t.assertTSInterfaceDeclaration.apply(t, arguments);
  },

  assertTSIntersectionType(value, opts) {
    return t.assertTSIntersectionType.apply(t, arguments);
  },

  assertTSLiteralType(value, opts) {
    return t.assertTSLiteralType.apply(t, arguments);
  },

  assertTSMappedType(value, opts) {
    return t.assertTSMappedType.apply(t, arguments);
  },

  assertTSMethodSignature(value, opts) {
    return t.assertTSMethodSignature.apply(t, arguments);
  },

  assertTSModuleBlock(value, opts) {
    return t.assertTSModuleBlock.apply(t, arguments);
  },

  assertTSModuleDeclaration(value, opts) {
    return t.assertTSModuleDeclaration.apply(t, arguments);
  },

  assertTSNamespaceExportDeclaration(value, opts) {
    return t.assertTSNamespaceExportDeclaration.apply(t, arguments);
  },

  assertTSNeverKeyword(value, opts) {
    return t.assertTSNeverKeyword.apply(t, arguments);
  },

  assertTSNonNullExpression(value, opts) {
    return t.assertTSNonNullExpression.apply(t, arguments);
  },

  assertTSNullKeyword(value, opts) {
    return t.assertTSNullKeyword.apply(t, arguments);
  },

  assertTSNumberKeyword(value, opts) {
    return t.assertTSNumberKeyword.apply(t, arguments);
  },

  assertTSObjectKeyword(value, opts) {
    return t.assertTSObjectKeyword.apply(t, arguments);
  },

  assertTSOptionalType(value, opts) {
    return t.assertTSOptionalType.apply(t, arguments);
  },

  assertTSParameterProperty(value, opts) {
    return t.assertTSParameterProperty.apply(t, arguments);
  },

  assertTSParenthesizedType(value, opts) {
    return t.assertTSParenthesizedType.apply(t, arguments);
  },

  assertTSPropertySignature(value, opts) {
    return t.assertTSPropertySignature.apply(t, arguments);
  },

  assertTSQualifiedName(value, opts) {
    return t.assertTSQualifiedName.apply(t, arguments);
  },

  assertTSRestType(value, opts) {
    return t.assertTSRestType.apply(t, arguments);
  },

  assertTSStringKeyword(value, opts) {
    return t.assertTSStringKeyword.apply(t, arguments);
  },

  assertTSSymbolKeyword(value, opts) {
    return t.assertTSSymbolKeyword.apply(t, arguments);
  },

  assertTSThisType(value, opts) {
    return t.assertTSThisType.apply(t, arguments);
  },

  assertTSTupleType(value, opts) {
    return t.assertTSTupleType.apply(t, arguments);
  },

  assertTSTypeAliasDeclaration(value, opts) {
    return t.assertTSTypeAliasDeclaration.apply(t, arguments);
  },

  assertTSTypeAnnotation(value, opts) {
    return t.assertTSTypeAnnotation.apply(t, arguments);
  },

  assertTSTypeAssertion(value, opts) {
    return t.assertTSTypeAssertion.apply(t, arguments);
  },

  assertTSTypeLiteral(value, opts) {
    return t.assertTSTypeLiteral.apply(t, arguments);
  },

  assertTSTypeOperator(value, opts) {
    return t.assertTSTypeOperator.apply(t, arguments);
  },

  assertTSTypeParameter(value, opts) {
    return t.assertTSTypeParameter.apply(t, arguments);
  },

  assertTSTypeParameterDeclaration(value, opts) {
    return t.assertTSTypeParameterDeclaration.apply(t, arguments);
  },

  assertTSTypeParameterInstantiation(value, opts) {
    return t.assertTSTypeParameterInstantiation.apply(t, arguments);
  },

  assertTSTypePredicate(value, opts) {
    return t.assertTSTypePredicate.apply(t, arguments);
  },

  assertTSTypeQuery(value, opts) {
    return t.assertTSTypeQuery.apply(t, arguments);
  },

  assertTSTypeReference(value, opts) {
    return t.assertTSTypeReference.apply(t, arguments);
  },

  assertTSUndefinedKeyword(value, opts) {
    return t.assertTSUndefinedKeyword.apply(t, arguments);
  },

  assertTSUnionType(value, opts) {
    return t.assertTSUnionType.apply(t, arguments);
  },

  assertTSUnknownKeyword(value, opts) {
    return t.assertTSUnknownKeyword.apply(t, arguments);
  },

  assertTSVoidKeyword(value, opts) {
    return t.assertTSVoidKeyword.apply(t, arguments);
  },

  assertTaggedTemplateExpression(value, opts) {
    return t.assertTaggedTemplateExpression.apply(t, arguments);
  },

  assertTemplateElement(value, opts) {
    return t.assertTemplateElement.apply(t, arguments);
  },

  assertTemplateLiteral(value, opts) {
    return t.assertTemplateLiteral.apply(t, arguments);
  },

  assertThisExpression(value, opts) {
    return t.assertThisExpression.apply(t, arguments);
  },

  assertThisTypeAnnotation(value, opts) {
    return t.assertThisTypeAnnotation.apply(t, arguments);
  },

  assertThrowStatement(value, opts) {
    return t.assertThrowStatement.apply(t, arguments);
  },

  assertTryStatement(value, opts) {
    return t.assertTryStatement.apply(t, arguments);
  },

  assertTupleTypeAnnotation(value, opts) {
    return t.assertTupleTypeAnnotation.apply(t, arguments);
  },

  assertTypeAlias(value, opts) {
    return t.assertTypeAlias.apply(t, arguments);
  },

  assertTypeAnnotation(value, opts) {
    return t.assertTypeAnnotation.apply(t, arguments);
  },

  assertTypeCastExpression(value, opts) {
    return t.assertTypeCastExpression.apply(t, arguments);
  },

  assertTypeParameter(value, opts) {
    return t.assertTypeParameter.apply(t, arguments);
  },

  assertTypeParameterDeclaration(value, opts) {
    return t.assertTypeParameterDeclaration.apply(t, arguments);
  },

  assertTypeParameterInstantiation(value, opts) {
    return t.assertTypeParameterInstantiation.apply(t, arguments);
  },

  assertTypeofTypeAnnotation(value, opts) {
    return t.assertTypeofTypeAnnotation.apply(t, arguments);
  },

  assertUnaryExpression(value, opts) {
    return t.assertUnaryExpression.apply(t, arguments);
  },

  assertUnionTypeAnnotation(value, opts) {
    return t.assertUnionTypeAnnotation.apply(t, arguments);
  },

  assertUpdateExpression(value, opts) {
    return t.assertUpdateExpression.apply(t, arguments);
  },

  assertVariableDeclaration(value, opts) {
    return t.assertVariableDeclaration.apply(t, arguments);
  },

  assertVariableDeclarator(value, opts) {
    return t.assertVariableDeclarator.apply(t, arguments);
  },

  assertVariance(value, opts) {
    return t.assertVariance.apply(t, arguments);
  },

  assertVoidTypeAnnotation(value, opts) {
    return t.assertVoidTypeAnnotation.apply(t, arguments);
  },

  assertWhileStatement(value, opts) {
    return t.assertWhileStatement.apply(t, arguments);
  },

  assertWithStatement(value, opts) {
    return t.assertWithStatement.apply(t, arguments);
  },

  assertYieldExpression(value, opts) {
    return t.assertYieldExpression.apply(t, arguments);
  },

  asAnyTypeAnnotation(value, opts) {
    return t.isAnyTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asArrayExpression(value, opts) {
    return t.isArrayExpression.apply(t, arguments) ? value : undefined;
  },

  asArrayPattern(value, opts) {
    return t.isArrayPattern.apply(t, arguments) ? value : undefined;
  },

  asArrayTypeAnnotation(value, opts) {
    return t.isArrayTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asArrowFunctionExpression(value, opts) {
    return t.isArrowFunctionExpression.apply(t, arguments) ? value : undefined;
  },

  asAssignmentExpression(value, opts) {
    return t.isAssignmentExpression.apply(t, arguments) ? value : undefined;
  },

  asAssignmentPattern(value, opts) {
    return t.isAssignmentPattern.apply(t, arguments) ? value : undefined;
  },

  asAwaitExpression(value, opts) {
    return t.isAwaitExpression.apply(t, arguments) ? value : undefined;
  },

  asBigIntLiteral(value, opts) {
    return t.isBigIntLiteral.apply(t, arguments) ? value : undefined;
  },

  asBinaryExpression(value, opts) {
    return t.isBinaryExpression.apply(t, arguments) ? value : undefined;
  },

  asBindExpression(value, opts) {
    return t.isBindExpression.apply(t, arguments) ? value : undefined;
  },

  asBlockStatement(value, opts) {
    return t.isBlockStatement.apply(t, arguments) ? value : undefined;
  },

  asBooleanLiteral(value, opts) {
    return t.isBooleanLiteral.apply(t, arguments) ? value : undefined;
  },

  asBooleanLiteralTypeAnnotation(value, opts) {
    return t.isBooleanLiteralTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asBooleanTypeAnnotation(value, opts) {
    return t.isBooleanTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asBreakStatement(value, opts) {
    return t.isBreakStatement.apply(t, arguments) ? value : undefined;
  },

  asCallExpression(value, opts) {
    return t.isCallExpression.apply(t, arguments) ? value : undefined;
  },

  asCatchClause(value, opts) {
    return t.isCatchClause.apply(t, arguments) ? value : undefined;
  },

  asClassBody(value, opts) {
    return t.isClassBody.apply(t, arguments) ? value : undefined;
  },

  asClassDeclaration(value, opts) {
    return t.isClassDeclaration.apply(t, arguments) ? value : undefined;
  },

  asClassExpression(value, opts) {
    return t.isClassExpression.apply(t, arguments) ? value : undefined;
  },

  asClassImplements(value, opts) {
    return t.isClassImplements.apply(t, arguments) ? value : undefined;
  },

  asClassMethod(value, opts) {
    return t.isClassMethod.apply(t, arguments) ? value : undefined;
  },

  asClassPrivateMethod(value, opts) {
    return t.isClassPrivateMethod.apply(t, arguments) ? value : undefined;
  },

  asClassPrivateProperty(value, opts) {
    return t.isClassPrivateProperty.apply(t, arguments) ? value : undefined;
  },

  asClassProperty(value, opts) {
    return t.isClassProperty.apply(t, arguments) ? value : undefined;
  },

  asConditionalExpression(value, opts) {
    return t.isConditionalExpression.apply(t, arguments) ? value : undefined;
  },

  asContinueStatement(value, opts) {
    return t.isContinueStatement.apply(t, arguments) ? value : undefined;
  },

  asDebuggerStatement(value, opts) {
    return t.isDebuggerStatement.apply(t, arguments) ? value : undefined;
  },

  asDeclareClass(value, opts) {
    return t.isDeclareClass.apply(t, arguments) ? value : undefined;
  },

  asDeclareExportAllDeclaration(value, opts) {
    return t.isDeclareExportAllDeclaration.apply(t, arguments) ? value : undefined;
  },

  asDeclareExportDeclaration(value, opts) {
    return t.isDeclareExportDeclaration.apply(t, arguments) ? value : undefined;
  },

  asDeclareFunction(value, opts) {
    return t.isDeclareFunction.apply(t, arguments) ? value : undefined;
  },

  asDeclareInterface(value, opts) {
    return t.isDeclareInterface.apply(t, arguments) ? value : undefined;
  },

  asDeclareModule(value, opts) {
    return t.isDeclareModule.apply(t, arguments) ? value : undefined;
  },

  asDeclareModuleExports(value, opts) {
    return t.isDeclareModuleExports.apply(t, arguments) ? value : undefined;
  },

  asDeclareOpaqueType(value, opts) {
    return t.isDeclareOpaqueType.apply(t, arguments) ? value : undefined;
  },

  asDeclareTypeAlias(value, opts) {
    return t.isDeclareTypeAlias.apply(t, arguments) ? value : undefined;
  },

  asDeclareVariable(value, opts) {
    return t.isDeclareVariable.apply(t, arguments) ? value : undefined;
  },

  asDeclaredPredicate(value, opts) {
    return t.isDeclaredPredicate.apply(t, arguments) ? value : undefined;
  },

  asDecorator(value, opts) {
    return t.isDecorator.apply(t, arguments) ? value : undefined;
  },

  asDirective(value, opts) {
    return t.isDirective.apply(t, arguments) ? value : undefined;
  },

  asDirectiveLiteral(value, opts) {
    return t.isDirectiveLiteral.apply(t, arguments) ? value : undefined;
  },

  asDoExpression(value, opts) {
    return t.isDoExpression.apply(t, arguments) ? value : undefined;
  },

  asDoWhileStatement(value, opts) {
    return t.isDoWhileStatement.apply(t, arguments) ? value : undefined;
  },

  asEmptyStatement(value, opts) {
    return t.isEmptyStatement.apply(t, arguments) ? value : undefined;
  },

  asEmptyTypeAnnotation(value, opts) {
    return t.isEmptyTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asExistsTypeAnnotation(value, opts) {
    return t.isExistsTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asExportAllDeclaration(value, opts) {
    return t.isExportAllDeclaration.apply(t, arguments) ? value : undefined;
  },

  asExportDefaultDeclaration(value, opts) {
    return t.isExportDefaultDeclaration.apply(t, arguments) ? value : undefined;
  },

  asExportDefaultSpecifier(value, opts) {
    return t.isExportDefaultSpecifier.apply(t, arguments) ? value : undefined;
  },

  asExportNamedDeclaration(value, opts) {
    return t.isExportNamedDeclaration.apply(t, arguments) ? value : undefined;
  },

  asExportNamespaceSpecifier(value, opts) {
    return t.isExportNamespaceSpecifier.apply(t, arguments) ? value : undefined;
  },

  asExportSpecifier(value, opts) {
    return t.isExportSpecifier.apply(t, arguments) ? value : undefined;
  },

  asExpressionStatement(value, opts) {
    return t.isExpressionStatement.apply(t, arguments) ? value : undefined;
  },

  asFile(value, opts) {
    return t.isFile.apply(t, arguments) ? value : undefined;
  },

  asForInStatement(value, opts) {
    return t.isForInStatement.apply(t, arguments) ? value : undefined;
  },

  asForOfStatement(value, opts) {
    return t.isForOfStatement.apply(t, arguments) ? value : undefined;
  },

  asForStatement(value, opts) {
    return t.isForStatement.apply(t, arguments) ? value : undefined;
  },

  asFunctionDeclaration(value, opts) {
    return t.isFunctionDeclaration.apply(t, arguments) ? value : undefined;
  },

  asFunctionExpression(value, opts) {
    return t.isFunctionExpression.apply(t, arguments) ? value : undefined;
  },

  asFunctionTypeAnnotation(value, opts) {
    return t.isFunctionTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asFunctionTypeParam(value, opts) {
    return t.isFunctionTypeParam.apply(t, arguments) ? value : undefined;
  },

  asGenericTypeAnnotation(value, opts) {
    return t.isGenericTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asIdentifier(value, opts) {
    return t.isIdentifier.apply(t, arguments) ? value : undefined;
  },

  asIfStatement(value, opts) {
    return t.isIfStatement.apply(t, arguments) ? value : undefined;
  },

  asImport(value, opts) {
    return t.isImport.apply(t, arguments) ? value : undefined;
  },

  asImportDeclaration(value, opts) {
    return t.isImportDeclaration.apply(t, arguments) ? value : undefined;
  },

  asImportDefaultSpecifier(value, opts) {
    return t.isImportDefaultSpecifier.apply(t, arguments) ? value : undefined;
  },

  asImportNamespaceSpecifier(value, opts) {
    return t.isImportNamespaceSpecifier.apply(t, arguments) ? value : undefined;
  },

  asImportSpecifier(value, opts) {
    return t.isImportSpecifier.apply(t, arguments) ? value : undefined;
  },

  asInferredPredicate(value, opts) {
    return t.isInferredPredicate.apply(t, arguments) ? value : undefined;
  },

  asInterfaceDeclaration(value, opts) {
    return t.isInterfaceDeclaration.apply(t, arguments) ? value : undefined;
  },

  asInterfaceExtends(value, opts) {
    return t.isInterfaceExtends.apply(t, arguments) ? value : undefined;
  },

  asInterfaceTypeAnnotation(value, opts) {
    return t.isInterfaceTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asInterpreterDirective(value, opts) {
    return t.isInterpreterDirective.apply(t, arguments) ? value : undefined;
  },

  asIntersectionTypeAnnotation(value, opts) {
    return t.isIntersectionTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asJSXAttribute(value, opts) {
    return t.isJSXAttribute.apply(t, arguments) ? value : undefined;
  },

  asJSXClosingElement(value, opts) {
    return t.isJSXClosingElement.apply(t, arguments) ? value : undefined;
  },

  asJSXClosingFragment(value, opts) {
    return t.isJSXClosingFragment.apply(t, arguments) ? value : undefined;
  },

  asJSXElement(value, opts) {
    return t.isJSXElement.apply(t, arguments) ? value : undefined;
  },

  asJSXEmptyExpression(value, opts) {
    return t.isJSXEmptyExpression.apply(t, arguments) ? value : undefined;
  },

  asJSXExpressionContainer(value, opts) {
    return t.isJSXExpressionContainer.apply(t, arguments) ? value : undefined;
  },

  asJSXFragment(value, opts) {
    return t.isJSXFragment.apply(t, arguments) ? value : undefined;
  },

  asJSXIdentifier(value, opts) {
    return t.isJSXIdentifier.apply(t, arguments) ? value : undefined;
  },

  asJSXMemberExpression(value, opts) {
    return t.isJSXMemberExpression.apply(t, arguments) ? value : undefined;
  },

  asJSXNamespacedName(value, opts) {
    return t.isJSXNamespacedName.apply(t, arguments) ? value : undefined;
  },

  asJSXOpeningElement(value, opts) {
    return t.isJSXOpeningElement.apply(t, arguments) ? value : undefined;
  },

  asJSXOpeningFragment(value, opts) {
    return t.isJSXOpeningFragment.apply(t, arguments) ? value : undefined;
  },

  asJSXSpreadAttribute(value, opts) {
    return t.isJSXSpreadAttribute.apply(t, arguments) ? value : undefined;
  },

  asJSXSpreadChild(value, opts) {
    return t.isJSXSpreadChild.apply(t, arguments) ? value : undefined;
  },

  asJSXText(value, opts) {
    return t.isJSXText.apply(t, arguments) ? value : undefined;
  },

  asLabeledStatement(value, opts) {
    return t.isLabeledStatement.apply(t, arguments) ? value : undefined;
  },

  asLogicalExpression(value, opts) {
    return t.isLogicalExpression.apply(t, arguments) ? value : undefined;
  },

  asMemberExpression(value, opts) {
    return t.isMemberExpression.apply(t, arguments) ? value : undefined;
  },

  asMetaProperty(value, opts) {
    return t.isMetaProperty.apply(t, arguments) ? value : undefined;
  },

  asMixedTypeAnnotation(value, opts) {
    return t.isMixedTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asNewExpression(value, opts) {
    return t.isNewExpression.apply(t, arguments) ? value : undefined;
  },

  asNoop(value, opts) {
    return t.isNoop.apply(t, arguments) ? value : undefined;
  },

  asNullLiteral(value, opts) {
    return t.isNullLiteral.apply(t, arguments) ? value : undefined;
  },

  asNullLiteralTypeAnnotation(value, opts) {
    return t.isNullLiteralTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asNullableTypeAnnotation(value, opts) {
    return t.isNullableTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asNumberLiteralTypeAnnotation(value, opts) {
    return t.isNumberLiteralTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asNumberTypeAnnotation(value, opts) {
    return t.isNumberTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asNumericLiteral(value, opts) {
    return t.isNumericLiteral.apply(t, arguments) ? value : undefined;
  },

  asObjectExpression(value, opts) {
    return t.isObjectExpression.apply(t, arguments) ? value : undefined;
  },

  asObjectMethod(value, opts) {
    return t.isObjectMethod.apply(t, arguments) ? value : undefined;
  },

  asObjectPattern(value, opts) {
    return t.isObjectPattern.apply(t, arguments) ? value : undefined;
  },

  asObjectProperty(value, opts) {
    return t.isObjectProperty.apply(t, arguments) ? value : undefined;
  },

  asObjectTypeAnnotation(value, opts) {
    return t.isObjectTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asObjectTypeCallProperty(value, opts) {
    return t.isObjectTypeCallProperty.apply(t, arguments) ? value : undefined;
  },

  asObjectTypeIndexer(value, opts) {
    return t.isObjectTypeIndexer.apply(t, arguments) ? value : undefined;
  },

  asObjectTypeInternalSlot(value, opts) {
    return t.isObjectTypeInternalSlot.apply(t, arguments) ? value : undefined;
  },

  asObjectTypeProperty(value, opts) {
    return t.isObjectTypeProperty.apply(t, arguments) ? value : undefined;
  },

  asObjectTypeSpreadProperty(value, opts) {
    return t.isObjectTypeSpreadProperty.apply(t, arguments) ? value : undefined;
  },

  asOpaqueType(value, opts) {
    return t.isOpaqueType.apply(t, arguments) ? value : undefined;
  },

  asOptionalCallExpression(value, opts) {
    return t.isOptionalCallExpression.apply(t, arguments) ? value : undefined;
  },

  asOptionalMemberExpression(value, opts) {
    return t.isOptionalMemberExpression.apply(t, arguments) ? value : undefined;
  },

  asParenthesizedExpression(value, opts) {
    return t.isParenthesizedExpression.apply(t, arguments) ? value : undefined;
  },

  asPipelineBareFunction(value, opts) {
    return t.isPipelineBareFunction.apply(t, arguments) ? value : undefined;
  },

  asPipelinePrimaryTopicReference(value, opts) {
    return t.isPipelinePrimaryTopicReference.apply(t, arguments) ? value : undefined;
  },

  asPipelineTopicExpression(value, opts) {
    return t.isPipelineTopicExpression.apply(t, arguments) ? value : undefined;
  },

  asPrivateName(value, opts) {
    return t.isPrivateName.apply(t, arguments) ? value : undefined;
  },

  asProgram(value, opts) {
    return t.isProgram.apply(t, arguments) ? value : undefined;
  },

  asQualifiedTypeIdentifier(value, opts) {
    return t.isQualifiedTypeIdentifier.apply(t, arguments) ? value : undefined;
  },

  asRegExpLiteral(value, opts) {
    return t.isRegExpLiteral.apply(t, arguments) ? value : undefined;
  },

  asRestElement(value, opts) {
    return t.isRestElement.apply(t, arguments) ? value : undefined;
  },

  asReturnStatement(value, opts) {
    return t.isReturnStatement.apply(t, arguments) ? value : undefined;
  },

  asSequenceExpression(value, opts) {
    return t.isSequenceExpression.apply(t, arguments) ? value : undefined;
  },

  asSpreadElement(value, opts) {
    return t.isSpreadElement.apply(t, arguments) ? value : undefined;
  },

  asStringLiteral(value, opts) {
    return t.isStringLiteral.apply(t, arguments) ? value : undefined;
  },

  asStringLiteralTypeAnnotation(value, opts) {
    return t.isStringLiteralTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asStringTypeAnnotation(value, opts) {
    return t.isStringTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asSuper(value, opts) {
    return t.isSuper.apply(t, arguments) ? value : undefined;
  },

  asSwitchCase(value, opts) {
    return t.isSwitchCase.apply(t, arguments) ? value : undefined;
  },

  asSwitchStatement(value, opts) {
    return t.isSwitchStatement.apply(t, arguments) ? value : undefined;
  },

  asTSAnyKeyword(value, opts) {
    return t.isTSAnyKeyword.apply(t, arguments) ? value : undefined;
  },

  asTSArrayType(value, opts) {
    return t.isTSArrayType.apply(t, arguments) ? value : undefined;
  },

  asTSAsExpression(value, opts) {
    return t.isTSAsExpression.apply(t, arguments) ? value : undefined;
  },

  asTSBooleanKeyword(value, opts) {
    return t.isTSBooleanKeyword.apply(t, arguments) ? value : undefined;
  },

  asTSCallSignatureDeclaration(value, opts) {
    return t.isTSCallSignatureDeclaration.apply(t, arguments) ? value : undefined;
  },

  asTSConditionalType(value, opts) {
    return t.isTSConditionalType.apply(t, arguments) ? value : undefined;
  },

  asTSConstructSignatureDeclaration(value, opts) {
    return t.isTSConstructSignatureDeclaration.apply(t, arguments) ? value : undefined;
  },

  asTSConstructorType(value, opts) {
    return t.isTSConstructorType.apply(t, arguments) ? value : undefined;
  },

  asTSDeclareFunction(value, opts) {
    return t.isTSDeclareFunction.apply(t, arguments) ? value : undefined;
  },

  asTSDeclareMethod(value, opts) {
    return t.isTSDeclareMethod.apply(t, arguments) ? value : undefined;
  },

  asTSEnumDeclaration(value, opts) {
    return t.isTSEnumDeclaration.apply(t, arguments) ? value : undefined;
  },

  asTSEnumMember(value, opts) {
    return t.isTSEnumMember.apply(t, arguments) ? value : undefined;
  },

  asTSExportAssignment(value, opts) {
    return t.isTSExportAssignment.apply(t, arguments) ? value : undefined;
  },

  asTSExpressionWithTypeArguments(value, opts) {
    return t.isTSExpressionWithTypeArguments.apply(t, arguments) ? value : undefined;
  },

  asTSExternalModuleReference(value, opts) {
    return t.isTSExternalModuleReference.apply(t, arguments) ? value : undefined;
  },

  asTSFunctionType(value, opts) {
    return t.isTSFunctionType.apply(t, arguments) ? value : undefined;
  },

  asTSImportEqualsDeclaration(value, opts) {
    return t.isTSImportEqualsDeclaration.apply(t, arguments) ? value : undefined;
  },

  asTSIndexSignature(value, opts) {
    return t.isTSIndexSignature.apply(t, arguments) ? value : undefined;
  },

  asTSIndexedAccessType(value, opts) {
    return t.isTSIndexedAccessType.apply(t, arguments) ? value : undefined;
  },

  asTSInferType(value, opts) {
    return t.isTSInferType.apply(t, arguments) ? value : undefined;
  },

  asTSInterfaceBody(value, opts) {
    return t.isTSInterfaceBody.apply(t, arguments) ? value : undefined;
  },

  asTSInterfaceDeclaration(value, opts) {
    return t.isTSInterfaceDeclaration.apply(t, arguments) ? value : undefined;
  },

  asTSIntersectionType(value, opts) {
    return t.isTSIntersectionType.apply(t, arguments) ? value : undefined;
  },

  asTSLiteralType(value, opts) {
    return t.isTSLiteralType.apply(t, arguments) ? value : undefined;
  },

  asTSMappedType(value, opts) {
    return t.isTSMappedType.apply(t, arguments) ? value : undefined;
  },

  asTSMethodSignature(value, opts) {
    return t.isTSMethodSignature.apply(t, arguments) ? value : undefined;
  },

  asTSModuleBlock(value, opts) {
    return t.isTSModuleBlock.apply(t, arguments) ? value : undefined;
  },

  asTSModuleDeclaration(value, opts) {
    return t.isTSModuleDeclaration.apply(t, arguments) ? value : undefined;
  },

  asTSNamespaceExportDeclaration(value, opts) {
    return t.isTSNamespaceExportDeclaration.apply(t, arguments) ? value : undefined;
  },

  asTSNeverKeyword(value, opts) {
    return t.isTSNeverKeyword.apply(t, arguments) ? value : undefined;
  },

  asTSNonNullExpression(value, opts) {
    return t.isTSNonNullExpression.apply(t, arguments) ? value : undefined;
  },

  asTSNullKeyword(value, opts) {
    return t.isTSNullKeyword.apply(t, arguments) ? value : undefined;
  },

  asTSNumberKeyword(value, opts) {
    return t.isTSNumberKeyword.apply(t, arguments) ? value : undefined;
  },

  asTSObjectKeyword(value, opts) {
    return t.isTSObjectKeyword.apply(t, arguments) ? value : undefined;
  },

  asTSOptionalType(value, opts) {
    return t.isTSOptionalType.apply(t, arguments) ? value : undefined;
  },

  asTSParameterProperty(value, opts) {
    return t.isTSParameterProperty.apply(t, arguments) ? value : undefined;
  },

  asTSParenthesizedType(value, opts) {
    return t.isTSParenthesizedType.apply(t, arguments) ? value : undefined;
  },

  asTSPropertySignature(value, opts) {
    return t.isTSPropertySignature.apply(t, arguments) ? value : undefined;
  },

  asTSQualifiedName(value, opts) {
    return t.isTSQualifiedName.apply(t, arguments) ? value : undefined;
  },

  asTSRestType(value, opts) {
    return t.isTSRestType.apply(t, arguments) ? value : undefined;
  },

  asTSStringKeyword(value, opts) {
    return t.isTSStringKeyword.apply(t, arguments) ? value : undefined;
  },

  asTSSymbolKeyword(value, opts) {
    return t.isTSSymbolKeyword.apply(t, arguments) ? value : undefined;
  },

  asTSThisType(value, opts) {
    return t.isTSThisType.apply(t, arguments) ? value : undefined;
  },

  asTSTupleType(value, opts) {
    return t.isTSTupleType.apply(t, arguments) ? value : undefined;
  },

  asTSTypeAliasDeclaration(value, opts) {
    return t.isTSTypeAliasDeclaration.apply(t, arguments) ? value : undefined;
  },

  asTSTypeAnnotation(value, opts) {
    return t.isTSTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asTSTypeAssertion(value, opts) {
    return t.isTSTypeAssertion.apply(t, arguments) ? value : undefined;
  },

  asTSTypeLiteral(value, opts) {
    return t.isTSTypeLiteral.apply(t, arguments) ? value : undefined;
  },

  asTSTypeOperator(value, opts) {
    return t.isTSTypeOperator.apply(t, arguments) ? value : undefined;
  },

  asTSTypeParameter(value, opts) {
    return t.isTSTypeParameter.apply(t, arguments) ? value : undefined;
  },

  asTSTypeParameterDeclaration(value, opts) {
    return t.isTSTypeParameterDeclaration.apply(t, arguments) ? value : undefined;
  },

  asTSTypeParameterInstantiation(value, opts) {
    return t.isTSTypeParameterInstantiation.apply(t, arguments) ? value : undefined;
  },

  asTSTypePredicate(value, opts) {
    return t.isTSTypePredicate.apply(t, arguments) ? value : undefined;
  },

  asTSTypeQuery(value, opts) {
    return t.isTSTypeQuery.apply(t, arguments) ? value : undefined;
  },

  asTSTypeReference(value, opts) {
    return t.isTSTypeReference.apply(t, arguments) ? value : undefined;
  },

  asTSUndefinedKeyword(value, opts) {
    return t.isTSUndefinedKeyword.apply(t, arguments) ? value : undefined;
  },

  asTSUnionType(value, opts) {
    return t.isTSUnionType.apply(t, arguments) ? value : undefined;
  },

  asTSUnknownKeyword(value, opts) {
    return t.isTSUnknownKeyword.apply(t, arguments) ? value : undefined;
  },

  asTSVoidKeyword(value, opts) {
    return t.isTSVoidKeyword.apply(t, arguments) ? value : undefined;
  },

  asTaggedTemplateExpression(value, opts) {
    return t.isTaggedTemplateExpression.apply(t, arguments) ? value : undefined;
  },

  asTemplateElement(value, opts) {
    return t.isTemplateElement.apply(t, arguments) ? value : undefined;
  },

  asTemplateLiteral(value, opts) {
    return t.isTemplateLiteral.apply(t, arguments) ? value : undefined;
  },

  asThisExpression(value, opts) {
    return t.isThisExpression.apply(t, arguments) ? value : undefined;
  },

  asThisTypeAnnotation(value, opts) {
    return t.isThisTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asThrowStatement(value, opts) {
    return t.isThrowStatement.apply(t, arguments) ? value : undefined;
  },

  asTryStatement(value, opts) {
    return t.isTryStatement.apply(t, arguments) ? value : undefined;
  },

  asTupleTypeAnnotation(value, opts) {
    return t.isTupleTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asTypeAlias(value, opts) {
    return t.isTypeAlias.apply(t, arguments) ? value : undefined;
  },

  asTypeAnnotation(value, opts) {
    return t.isTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asTypeCastExpression(value, opts) {
    return t.isTypeCastExpression.apply(t, arguments) ? value : undefined;
  },

  asTypeParameter(value, opts) {
    return t.isTypeParameter.apply(t, arguments) ? value : undefined;
  },

  asTypeParameterDeclaration(value, opts) {
    return t.isTypeParameterDeclaration.apply(t, arguments) ? value : undefined;
  },

  asTypeParameterInstantiation(value, opts) {
    return t.isTypeParameterInstantiation.apply(t, arguments) ? value : undefined;
  },

  asTypeofTypeAnnotation(value, opts) {
    return t.isTypeofTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asUnaryExpression(value, opts) {
    return t.isUnaryExpression.apply(t, arguments) ? value : undefined;
  },

  asUnionTypeAnnotation(value, opts) {
    return t.isUnionTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asUpdateExpression(value, opts) {
    return t.isUpdateExpression.apply(t, arguments) ? value : undefined;
  },

  asVariableDeclaration(value, opts) {
    return t.isVariableDeclaration.apply(t, arguments) ? value : undefined;
  },

  asVariableDeclarator(value, opts) {
    return t.isVariableDeclarator.apply(t, arguments) ? value : undefined;
  },

  asVariance(value, opts) {
    return t.isVariance.apply(t, arguments) ? value : undefined;
  },

  asVoidTypeAnnotation(value, opts) {
    return t.isVoidTypeAnnotation.apply(t, arguments) ? value : undefined;
  },

  asWhileStatement(value, opts) {
    return t.isWhileStatement.apply(t, arguments) ? value : undefined;
  },

  asWithStatement(value, opts) {
    return t.isWithStatement.apply(t, arguments) ? value : undefined;
  },

  asYieldExpression(value, opts) {
    return t.isYieldExpression.apply(t, arguments) ? value : undefined;
  }

};
var _default2 = BabelTypes;
exports.default = _default2;